## 分布式锁zk和redis比较

## zk实现

核心是使用了zk临时顺序节点

1. 写入临时顺序节点
2. 判断自己写入的节点是不是当前需要最小的节点，如果是，就成功获得锁
3. 如果不是，就监听比自己需要小的节点，这个节点被删除了就能成功获得锁

## redis实现

获取锁的命令：

```ba
SET lock_key random_value NX PX 5000 
```

Nx->键不存在才能设置成功

PX 5000 ->过期时间为5000毫秒

释放锁lua脚本:

```lua
if redis.call('get',KEYS[1]) == ARGV[1] then 
   return redis.call('del',KEYS[1]) 
else
   return 0 
end
```

使用lua脚本是为了原子性，因为这个过程需要先获取key的值，查看是否和自己获得的锁的值是一致的才能释放。这里的KEYS[1]就是获取锁的时候的key，ARGV[1]就是设置的random_value，这样做是为了防止线程间错误释放。

## 比较

1. redis的实现，需要客户端不断的轮询，会消耗资源。zk的实现，通过监听器来触发
2. 主节点如果挂了，sentinal做了主节点转移，其实是可能出现redis的锁丢失的情况
3. zk不适合使用在大量写入的场景的，所以如果系统经常使用锁的话，zk可能会扛不住

