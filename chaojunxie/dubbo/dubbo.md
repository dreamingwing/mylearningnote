## dubbo

### 简介

RPC框架，实现了面向接口的RPC调用，实现了服务注册和发现、负载均衡、容错、扩展等

### 整体架构

![Architecture](http://dubbo.apache.org/img/architecture.png)

0. provider启动
1. provider向注册中心注册服务
2. consumer向注册中心订阅服务
3. 注册中心知会consumer
4. consumer调用provider提供的服务
5. monitor监控调用的次数和时间

### 分层以及组件

|   分层   |   组件    |                             描述                             |
| :------: | :-------: | :----------------------------------------------------------: |
|  业务层  |  Service  |               业务逻辑层，开发者主要关注在这层               |
|  rpc层   |  Config   |                 配置层，用来管理dubbo的配置                  |
|          |   proxy   |   代理层，provider和consumer都会生产proxy用来实现远程调用    |
|          | registry  |                注册层，用来服务注册和服务发现                |
|          |  Cluster  | 集群容错层，负责远程调用的容错策略，负载均衡策略以及路由策略 |
|          |  monitor  |              监控层，负责监控调用次数和调用时间              |
|          | protocol  |                远程调用层，封装调用的具体过程                |
| remoting | Exchange  |    信息交换层，建立request-response模型，封装请求响应模式    |
|          | transport |                          网络传输层                          |
|          | serialize |                           序列化层                           |

### 服务暴露

### 订阅服务

### 调用过程

- 服务器就得去注册中心注册，需要有个注册中心注册对应的信息，可以采用zookeeper进行注册。
- 接着消费者需要去注册中心获取对应的服务信息，而且每个服务可能存在于多台机器上。
- 接着就要发一次请求，怎么发起，通过动态代理的方式，面向接口获取到一个动态代理对象，这个动态代理就是接口在本地一个代理，然后这个代理会找到对应服务器的机器地址。
- 然后需要找到哪台机器发送请求，需要采用负载均衡算法，最简单的就是随机或者轮询
- 找到了对应机器，就可以发送请求了，怎么发？可以采用netty方式 怎么的数据发？需要序列化请求参数，然后请求就过去了，
- 服务那边也一样，需要针对自己的服务生成一个动态代理，监听某个网络端口，然后代理你本地的服务代码，接受到请求的时候，就调用服务代码，整个调用过程结束

十层架构：业务层  ->  配置层  ->  代理层  -> 注册层  -> 路由层 -> 监控层 ->远程调用层 ->信息交换层 ->传输层 ->序列化层

### SPI



