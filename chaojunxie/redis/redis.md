## Redis

+ 基本数据类型
  1. 字符串-string

     redis中最基本的数据结构，string类型不单可以存字符串，也可以存数字。

     使用场景：字典值，简单的一些统计

     主要的命令包括：set，get，decr，incr，mget等

  2. 字典-hash

     一组key-value结构，适合用来存放对象，一对k-v就代表一个属性和值。例如可以存放商品信息，用户个人信息等。

     使用场景：存放一些详情信息，例如商品详情、用户个人信息、会员详细信息等

     主要命令包括：hset，hget，hgetall等

  3. 列表-list

     本质上的实现是个双向链表，所以可以通过正向和反向查询。

     使用场景：列表页面的信息，例如商品列表、会员列表、用户列表

     主要命令包括：lpush，rpush，lpop，rpop，lrange等

  4. 集合-set

     会去重。能实现交集(sinter，sinterstore)，并集(sunion，sunionstore)，差集(sdiff，sdiffstore)等操作。

     使用场景：不能出现重复的列表场景，例如交集取共同好友，或者说打标签之类的

     主要命令包括：sadd，spop，smembers，sunion。

  5. 有序结合-sortedset

     和set相比，增加了一个score参数。集合中的元素会根据score进行排序。

     使用场景：实现一些类似于排行榜的功能，因为通过score排序

     主要命令包括：zadd，zrange，zrem，zcard等

+ 持久化

  1. RDB-全量

     Redis可以通过创建快照来保存某个时间点上在内存中的数据副本，这个就是RDB文件备份。这个文件可以同步给其他服务器从而实现Redis主从架构。也可以保留在本地方便重启。恢复数据的时候，RDB文件会比AOF文件要快。但是相比较起来，如果宕机，丢失的数据会更多，因为生成的频率较低。

     实现的原理主要是fork+copy on write。接收到bgsave命令的时候，Redis会fork一条子线程出来进行rdb文件的保存。父进程和子进程共享内存内存区域，父进程继续提供读写服务。

     下面是redis.conf中关于rdb备份时间的配置

     ```properties
     save 900 1 #900秒之后，至少有个1个key发生变化，就回触发bgsave命令创建快照
     save 300 10 #300秒之后，至少有个10个key发生变化，就回触发bgsave命令创建快照
     save 60 10000 #60秒之后，至少有个10000个key发生变化，就回触发bgsave命令创建快照
     ```

  2. AOF-增量

     每执行一条修改数据的操作都会将该命令写入到AOF文件当中。相对于RDB来说，AOF回复数据的速度相对慢，但是能恢复更多的数据。如果使用了AOF，redis会默认使用aof文件来恢复数据。

     默认是关闭的，需要在redis.conf中设置

     ```properties
     appendonly yes
     ```

     来开启。

     AOF的持久化可以配置为:

     ```properties
     appendfsync always #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis 的速度
     appendfsync everysec #每秒钟同步一次，显示地将多个写命令同步到硬盘 
     appendfsync no #让操作系统决定何时进行同步
     ```

+ 使用场景

  1. 分布式锁

     获取锁的命令：

     ```ba
     SET lock_key random_value NX PX 5000 
     ```

     Nx->键不存在才能设置成功

     PX 5000 ->过期时间为5000毫秒

     释放锁lua脚本:

     ```lua
     if redis.call('get',KEYS[1]) == ARGV[1] then 
        return redis.call('del',KEYS[1]) 
     else
        return 0 
     end
     ```

     使用lua脚本是为了原子性，因为这个过程需要先获取key的值，查看是否和自己获得的锁的值是一致的才能释放。这里的KEYS[1]就是获取锁的时候的key，ARGV[1]就是设置的random_value，这样做是为了防止线程间错误释放。

  2. 异步队列

     使用list结构，写入的时候用rpush，读出的时候用lpop，当lpop没有消息的时候，sleep一会再读。也可以用blpop，这个会阻塞直到有消息。

  3. 延时队列

     使用sorted set结构。把时间作为score，然后用zrangebyscore来获取取件范围内的数据

+ 线程模型

  Redis内部使用文件事件处理器(file event handler)的机制，这个处理器会是单线程的，通过IO多路复用的监听多个socket。每个socket不同的操作会产生不同的文件事件，这些文件事件会被放置到队列中，然后文件事件分派器会在队列中取出事件，分配给不同的事件处理器来处理事件。

+ 主从架构

  Redis主从架构一般都是为了读写分离，通过主库写入，读取的时候通过从库读取。

  在从库设置slaveof参数来设置指向哪个主库。主从同步的方式有两种：

  1. 快照同步

     快照同步的过程从库会从主库拉取RDB文件，然后从库会把自身的所有数据清空，然后加载RDB文件。在这个同步的过程中，主库的所有写入操作，都会缓存到buffer到起来，当从库加载完快照以后，就会把buffer中的指令同步给从库。如果有多个从库，只会有一份RDB文件。

  2. 增量同步

     主库中的所有写操作都会缓存到buffer中，然后会异步的把这些指令同步到从库，从库执行。

+ 哨兵模式

  哨兵是一个独立的进程，它是通过发送命令，等待Redis服务器的响应，从而监控多个Redis实例。当哨兵检测的redis主库挂了，会通过发布订阅模式切换主库。从而保证高可用。

  假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，将其视为客观下线状态，那么哨兵之间就会进行一次投票，投票的结果为一个领头哨兵，发起进行failover操作，首先是从主服务器的从服务器中选出一个从服务器作为新的主服务器。选点的依据依次是：网络连接正常->5秒内回复过INFO命令->10*down-after-milliseconds内与主连接过的->从服务器优先级->复制偏移量->运行id较小的。选出之后通过slaveif no ont将该从服务器升为新主服务器。通过slaveof ip port命令让其他从服务器以改服务器为主服务器。 

  故障转移成功后会通过发布订阅连接广播新的配置信息，其他sentinel收到后依据配置纪元更大来更新主服务器信息。

  注：最后当旧主重新连接后将其变为新主的从服务器。注意如果客户端与就主服务器分隔在一起，写入的数据在恢复后由于旧主会复制新主的数据会造成数据丢失。

  所以，哨兵是需要最起码三个节点。如果只有两个节点，当master机器挂了，会无法进行转移，因为值只有一个哨兵发现了主节点挂了，没法投票。

  选主算法：TODO

+ 发布订阅模式

  Redis支持发布订阅模式，生产者通过publish往指定的channel里面写入消息，消费者通过subscribe命令监听channel来获取消息。通过这个机制，能实现简单的消息队列或者消息广播。但是和专业的消息队列相比，sub/pub模式的一个问题是，消费者下线了以后无法消费消息，所以只适合做简单的广播。

+ 事务

  Redis的事务是通过multi, exec, watch, unwatch来实现的。在一个事务中，如果是语法错误，是会整体失败。如果是类型错误的话，只会失败这一句，别的都会继续执行。如果要整体回滚，需要用到watch命令。

+ 过期删除策略

  主要是为了删除过期的key

  1. 定期删除

     每过一段时间(默认100ms)，redis会随机抽取一些设置了过期过期时间的key，检查这些key是否过期，如果过期就删除

  2. 惰性删除

     惰性删除，也就是到了查这个key的时候去判断是否需要删除

+ 内存淘汰策略

  内存不够的时候，需要使用内存淘汰策略来淘汰一些key来释放内存

  1. Volatile-lru

     从设置了有效期的key里面，删除最近最少使用的。

  2. Volatile-ttl

     从设置了有效期的key里面，删除将要过期的

  3. Volatile-random

     从设置了有效期的key里面，随机删除

  4. Allkeys-lru

     从全部的key里面，删除最近最少使用的

  5. Allkeys-random

     从全部的key里面，随机删除

  6. No-eviction

     不会删除数据，当没法写入的时候，写入会报错

  7. Volatile-lfu(4.0)

     从设置了有效期的key里面，删除最近最不经常使用的

  8. Allkeys-lfu(4.0)

     从全部的key里面，删除最近最不经常使用的

+ 为什么效率高

  1. 纯内存操作
  2. 线程模型是非阻塞的IO多路复用
  3. 没有上下文切换

+ 常见问题
  1. 缓存雪崩

     在某一时刻，大量的key同时失效，如果恰好在这个时间有大量的涉及到这些key的请求涌入，就会导致全部请求落到数据库，这样会使得数据库扛不住请求量。如果实在分布式情况下，该服务没有做降级或者熔断的，就回导致其他依赖于该服务的接口都会报错。这样的情况叫做缓存雪崩。

     解决方案：

     1. 对于每个key，在失效时间的基础上加个随机值
     2. 对于某些key，设置永远不过期

  2. 缓存穿透

     缓存穿透式指查询在redis和数据库中一定不存在的数据。例如，在一个商品表中查询id为0或者说负数的商品，这样会导致请求一定落入到数据中查询。如果是大量的这样请求，回压垮数据库。

     解决方案：

     1. 请求的时候做校验
     2. 使用布隆过滤器

  3. 缓存击穿

     缓存击穿是指某个特别热的key突然失效，而且同时在这个时间也有大量对于这个key的请求涌入，会导致全部的请求到会落到数据库。

     解决方案：

     1. 这个key永不过期
     2. 在数据库读取该key的值得时候，使用互斥锁来读取

  4. 数据库缓存一致

     核心都是cache aside pattern。读的时候，先从缓存读，读不到就去db读，然后写到缓存。更新的时候，先更新数据库，然后删除缓存。但是这些方案都不能保证一定一致，所以都是使用在一致性不太强的情况。如果是要求强一致，就直接都走DB。还有就是通过canal的形式，做最终一致性。

+ 布隆过滤器

  布隆过滤器的核心思路就是把一个元素，通过k个散列函数把这个元素映射到一个位数组中的k个点，设置成1。当查询的时候，同样的用这个k个散列函数散列到这k个点上，查看是不是都是1，如果是1那就大概率存在，如果其中有0那就肯定不存在。

  缺点：

  1. 存在误判
  2. 删除麻烦，因为不能把为止直接设置为0，可能影响别的元素

+ 单点登陆

+ session共享

+ raft算法