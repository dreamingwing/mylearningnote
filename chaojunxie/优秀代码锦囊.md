# 

## 1、缓存封装

缓存实体类 CacheParamDTO

~~~java
package com.newboss.base.dto;
import com.alibaba.fastjson.JSONObject;
import com.foxinmy.weixin4j.util.StringUtil;
import com.newboss.base.multidatasource.BizDivisionSwitch;
import com.newboss.base.multidatasource.BizDivisionType;
import com.newboss.base.multidatasource.DataSource;
import com.newboss.base.multidatasource.DataSourceInfoStackHolder;
import com.newboss.base.shiro.util.JwtUtil;
import com.newboss.base.util.DeflaterUtils;
import com.newboss.base.util.RedisUtil;
import lombok.Data;
import org.apache.poi.ss.formula.functions.T;
import org.springframework.util.Assert;

import java.io.Serializable;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.TimeUnit;
import java.util.function.Supplier;

/**
 * @author rover.chen 【chenliudong@xiao100.com】
 * @menu
 * @description
 * @date 2020/5/10 2:19
 * <p>
 * All rights Reserved, Designed www.xiao100.com
 */
@Data
public class CacheParamDTO<R, T extends Serializable>  implements Serializable {

    private static final long serialVersionUID = -3269780209162188785L;

    private String redisKeyPrefix;  //缓存前缀

    private Integer timeout;//

    private TimeUnit timeUnit;

    private T bizParams;

    private Supplier<R> bizHandler;

    private Integer refresh;

    private Boolean enable;  //定义是否启动缓存	

    private Integer stopRefreshAfterLastAccess;

    private Boolean skipValidate;

    private Boolean preserveNullOrEmptyValue;

    /**
     * 可空 随机时长范围
     */
    private Integer randomDuration;

    public static Builder builder()  {
        return new Builder();
    }

    private CacheParamDTO() {}

    public static class Builder<T extends Serializable, R extends Serializable> {

        private String redisKeyPrefix;

        private Integer timeout;

        private TimeUnit timeUnit;

        private T bizParams;

        private Supplier<R> bizHandler;

        private Integer refresh;

        private Integer stopRefreshAfterLastAccess;

        private Boolean preserveNullOrEmptyValue;

        private Boolean enable;

        private Boolean skipValidate;

        public Builder() {}

        /**
         * 可空 随机时长范围
         */
        private Integer randomDuration;

        public Builder redisKeyPrefix(String redisKeyPrefix) {
            this.redisKeyPrefix = redisKeyPrefix;
            return this;
        }

        public Builder refresh(Integer refresh) {
            this.refresh = refresh;
            return this;
        }

        public Builder stopRefreshAfterLastAccess(Integer refresh) {
            this.refresh = refresh;
            return this;
        }

        public Builder timeout(Integer timeout) {
            this.timeout = timeout;
            return this;
        }

        public Builder timeUnit(TimeUnit timeUnit) {
            this.timeUnit = timeUnit;
            return this;
        }

        public Builder bizParams(T bizParams) {
            this.bizParams = bizParams;
            return this;
        }

        public Builder bizHandler(Supplier<R> bizHandler) {
            this.bizHandler = bizHandler;
            return this;
        }

        public Builder randomDuration(Integer randomDuration) {
            this.randomDuration = randomDuration;
            return this;
        }

        public Builder enable(Boolean enable) {
            this.enable = enable;
            return this;
        }

        public Builder skipValidate(Boolean skipValidate) {
            this.skipValidate = skipValidate;
            return this;
        }

        public Builder preserveNullOrEmptyValue(Boolean preserveNullOrEmptyValue) {
            this.preserveNullOrEmptyValue = preserveNullOrEmptyValue;
            return this;
        }

        public CacheParamDTO build() {
            CacheParamDTO cacheParamDTO = new CacheParamDTO();
            cacheParamDTO.setRedisKeyPrefix(this.redisKeyPrefix);
            cacheParamDTO.setTimeout(this.timeout);
            cacheParamDTO.setTimeUnit(this.timeUnit);
            cacheParamDTO.setBizParams(this.bizParams);
            cacheParamDTO.setBizHandler(this.bizHandler);
            cacheParamDTO.setRandomDuration(this.randomDuration);
            cacheParamDTO.setEnable(this.enable);
            cacheParamDTO.setPreserveNullOrEmptyValue(this.preserveNullOrEmptyValue == null ? true : this.preserveNullOrEmptyValue);
            if(this.skipValidate != null && !this.skipValidate) {
                cacheParamDTO.validate();
            }
            return cacheParamDTO;
        }

        @Override
        public String toString() {
            return "Builder{" +
                    "redisKeyPrefix='" + redisKeyPrefix + '\'' +
                    ", timeout=" + timeout +
                    ", timeUnit=" + timeUnit +
                    ", bizParams=" + bizParams +
                    ", bizHandler=" + bizHandler +
                    ", refresh=" + refresh +
                    ", stopRefreshAfterLastAccess=" + stopRefreshAfterLastAccess +
                    ", enable=" + enable +
                    ", skipValidate=" + skipValidate +
                    ", skipValidate=" + skipValidate +
                    ", randomDuration=" + randomDuration +
                    '}';
        }
    }


    public void validate() {
        Assert.isTrue(StringUtil.isNotBlank(redisKeyPrefix)
                && Objects.nonNull(timeout)
                && Objects.nonNull(bizHandler)
                , "cache params validate error..."
        );
    }

    public String genCacheKey() {
        if(this.bizParams == null) {
            return redisKeyPrefix;
        }
        String bizParamsStr = this.bizParams instanceof String
                ? (String) this.bizParams : JSONObject.toJSONString(this.bizParams);
        String zipHashKey = DeflaterUtils.zipString(bizParamsStr);
        String xiaoStudentId = JwtUtil.getXiaoStudentId();
        if(StringUtil.isNotBlank(xiaoStudentId)) {
            return redisKeyPrefix.concat(xiaoStudentId).concat(":")
                    .concat(BizDivisionSwitch.getBizDivisionType().name())
                    .concat(":")
                    .concat(zipHashKey);
        }
        return redisKeyPrefix.concat(zipHashKey);
    }

    public String genCacheKeyByCondition(boolean hasStudentIdKey, boolean hasBizLineKey) {
        if (this.bizParams == null) {
            return redisKeyPrefix;
        }
        String cacheKey = redisKeyPrefix;
        String bizParamsStr = this.bizParams instanceof String
                ? (String) this.bizParams : JSONObject.toJSONString(this.bizParams);
        String zipHashKey = DeflaterUtils.zipString(bizParamsStr);
        String xiaoStudentId = JwtUtil.getXiaoStudentId();
        if (hasStudentIdKey && StringUtil.isNotBlank(xiaoStudentId)) {
            cacheKey = cacheKey.concat(xiaoStudentId).concat(":");
        }
        if (hasBizLineKey) {
            cacheKey = cacheKey.concat(BizDivisionSwitch.getBizDivisionType().name()).concat(":");
        }
        cacheKey = cacheKey.concat(zipHashKey);
        return cacheKey;
    }

    public int supplyRandomTimeout() {
        return this.timeout + Optional.ofNullable(this.getRandomDuration()).map(RedisUtil::getRandomTimeout).orElse(0);
    }
}

~~~

缓存的使用

~~~java
      //构建缓存对象
CacheParamDTO cacheParamDTO =
                CacheParamDTO.builder()
                .redisKeyPrefix(RedisKeyConstants.QUERY_PRODUCT_FROM_CC_PREFIX)
                .bizParams(reqBody)
                .timeout(30_000)
                .randomDuration(10_000)
                .timeUnit(TimeUnit.MILLISECONDS)
                .enable(true)
                .bizHandler(() -> courseCenterApi.queryProduct(reqBody).getData())
                .build();
    //处理缓存业务逻辑
CacheWrapperHandler.enableListCacheHandle(cacheParamDTO, AppProductRespDto.class);
~~~

缓存包装处理器

~~~java
package com.newboss.component;

import cn.hutool.core.collection.CollUtil;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.TypeReference;
import com.newboss.base.dto.CacheParamDTO;
import com.newboss.base.util.RedisUtil;
import lombok.extern.slf4j.Slf4j;
import org.junit.platform.commons.util.StringUtils;
import org.springframework.stereotype.Component;

import java.io.Serializable;
import java.util.List;
import java.util.Objects;
import java.util.Set;

/**
 * @author rover.chen 【chenliudong@xiao100.com】
 * @menu
 * @description 缓存包装处理器
 * @date 2020/5/10 22:36
 * <p>
 * All rights Reserved, Designed www.xiao100.com
 */

@Component
@Slf4j
public class CacheWrapperHandler {

    public static <T extends Serializable, S extends Serializable, R extends List<S>> R enableListCacheHandle(CacheParamDTO<R, T> cacheParamDTO, Class<S> doubleTypeClass) {
        Objects.requireNonNull(cacheParamDTO);
        R result;
        if (cacheParamDTO.getEnable() == null || cacheParamDTO.getEnable()) {
            //构建key
            String absRedisKey = cacheParamDTO.genCacheKey();
            //根据key获取value
            String cacheValue = RedisUtil.get(absRedisKey);
            if(StringUtils.isNotBlank(cacheValue) || RedisUtil.exists(absRedisKey)) {
                //双重获取 防止前次获取的值被更新后无感知的数据不一致问题
                cacheValue = RedisUtil.get(absRedisKey);
                log.info("absRedisKey:{}, value: {}", absRedisKey, cacheValue);
                if(StringUtils.isNotBlank(cacheValue)){
					return (R) JSONObject.parseObject(cacheValue, new TypeReference<List<S>>(doubleTypeClass) {});
				}
            }
            result = cacheParamDTO.getBizHandler().get();
            if(CollUtil.isNotEmpty(result) || cacheParamDTO.getPreserveNullOrEmptyValue()) {
                RedisUtil.set(
                        absRedisKey
                        , JSONObject.toJSONString(result)
                        , cacheParamDTO.supplyRandomTimeout()
                        , cacheParamDTO.getTimeUnit()
                );
            }
        } else {
            result = cacheParamDTO.getBizHandler().get();
        }

        return result;
    }

    public static <T extends Serializable, S extends Serializable, R extends Set<S>> R enableSetCacheHandle(CacheParamDTO<R, T> cacheParamDTO, Class<S> doubleTypeClass) {
        Objects.requireNonNull(cacheParamDTO);
        R result;
        if (cacheParamDTO.getEnable() == null || cacheParamDTO.getEnable()) {
            String absRedisKey = cacheParamDTO.genCacheKey();
            String cacheValue = RedisUtil.get(absRedisKey);
            if(StringUtils.isNotBlank(cacheValue) || RedisUtil.exists(absRedisKey)) {
                //双重获取 防止前次获取的值被更新后无感知的数据不一致问题
                cacheValue = RedisUtil.get(absRedisKey);
				log.info("absRedisKey:{}, value: {}", absRedisKey, cacheValue);
                if(StringUtils.isNotBlank(cacheValue)){
					return (R) JSONObject.parseObject(cacheValue, new TypeReference<Set<S>>(doubleTypeClass) {});
				}
            }
            result = cacheParamDTO.getBizHandler().get();
            if(CollUtil.isNotEmpty(result) || cacheParamDTO.getPreserveNullOrEmptyValue()) {
                RedisUtil.set(
                        absRedisKey
                        , JSONObject.toJSONString(result)
                        , cacheParamDTO.supplyRandomTimeout()
                        , cacheParamDTO.getTimeUnit()
                );
            }
        } else {
            result = cacheParamDTO.getBizHandler().get();
        }
        return result;
    }

        public static <T extends Serializable, R extends Serializable> R enableSingleObjCacheHandle(CacheParamDTO<R, T> cacheParamDTO, Class<R> rClass) {
        Objects.requireNonNull(cacheParamDTO);
        R result;
        if (cacheParamDTO.getEnable() == null || cacheParamDTO.getEnable()) {
            Objects.requireNonNull(cacheParamDTO);
            String absRedisKey = cacheParamDTO.genCacheKey();
            String cacheValue = RedisUtil.get(absRedisKey);
            if(StringUtils.isNotBlank(cacheValue) || RedisUtil.exists(absRedisKey)) {
                //双重获取 防止前次获取的值被更新后无感知的数据不一致问题
                cacheValue = RedisUtil.get(absRedisKey);
				log.info("absRedisKey:{}, value: {}", absRedisKey, cacheValue);
                if (StringUtils.isNotBlank(cacheValue)){
                    return JSONObject.parseObject(cacheValue, rClass);
                }
            }
            result = cacheParamDTO.getBizHandler().get();
            if(Objects.nonNull(result) || cacheParamDTO.getPreserveNullOrEmptyValue()) {
                RedisUtil.set(
                        absRedisKey
                        , JSONObject.toJSONString(result)
                        , cacheParamDTO.supplyRandomTimeout()
                        , cacheParamDTO.getTimeUnit()
                );
            }
        } else {
            result = cacheParamDTO.getBizHandler().get();
        }

        return result;
    }

    public static <T extends Serializable, S extends Serializable, R extends List<S>> R enableListCacheHandleWithKeyCondition(CacheParamDTO<R, T> cacheParamDTO,
                                                                                                              Class<S> doubleTypeClass,
                                                                                                              boolean hasStudentIdKey,
                                                                                                              boolean hasBizLineKey) {
        Objects.requireNonNull(cacheParamDTO);
        R result;
        if (cacheParamDTO.getEnable() == null || cacheParamDTO.getEnable()) {
            String absRedisKey = cacheParamDTO.genCacheKeyByCondition(hasStudentIdKey, hasBizLineKey);
            String cacheValue = RedisUtil.get(absRedisKey);
            if(StringUtils.isNotBlank(cacheValue) || RedisUtil.exists(absRedisKey)) {
                //双重获取 防止前次获取的值被更新后无感知的数据不一致问题
                cacheValue = RedisUtil.get(absRedisKey);
				log.info("absRedisKey:{}, value: {}", absRedisKey, cacheValue);
                if(StringUtils.isNotBlank(cacheValue)){
					return (R) JSONObject.parseObject(cacheValue, new TypeReference<List<S>>(doubleTypeClass) {});
				}
            }
            result = cacheParamDTO.getBizHandler().get();

            if(CollUtil.isNotEmpty(result) || cacheParamDTO.getPreserveNullOrEmptyValue()) {
                RedisUtil.set(
                        absRedisKey
                        , JSONObject.toJSONString(result)
                        , cacheParamDTO.supplyRandomTimeout()
                        , cacheParamDTO.getTimeUnit()
                );
            }
        } else {
            result = cacheParamDTO.getBizHandler().get();
        }

        return result;
    }
}
~~~

​	对字符串进行压缩处理及其解压缩

~~~java
package com.newboss.base.util;

import lombok.extern.slf4j.Slf4j;
import org.apache.shiro.codec.Base64;

import java.io.ByteArrayOutputStream;
import java.util.zip.DataFormatException;
import java.util.zip.Deflater;
import java.util.zip.Inflater;

/**
 * @author rover.chen 【chenliudong@xiao100.com】
 * @description <p>使用Deflater压缩json，Inflater解压json</p>
 *                 <p>Deflater 是同时使用了LZ77算法与哈夫曼编码的一个无损数据压缩算法。</p>
 * @date 2020/4/17 10:53
 * <p>
 * All rights Reserved, Designed www.xiao100.com
 */
@Slf4j
public class DeflaterUtils {

    private DeflaterUtils(){}

    /**
     * 压缩
     */
    public static String zipString(String unzipString) {
        /**
         *     https://www.yiibai.com/javazip/javazip_deflater.html#article-start
         *     0 ~ 9 压缩等级 低到高
         *     public static final int BEST_COMPRESSION = 9;            最佳压缩的压缩级别。
         *     public static final int BEST_SPEED = 1;                  压缩级别最快的压缩。
         *     public static final int DEFAULT_COMPRESSION = -1;        默认压缩级别。
         *     public static final int DEFAULT_STRATEGY = 0;            默认压缩策略。
         *     public static final int DEFLATED = 8;                    压缩算法的压缩方法(目前唯一支持的压缩方法)。
         *     public static final int FILTERED = 1;                    压缩策略最适用于大部分数值较小且数据分布随机分布的数据。
         *     public static final int FULL_FLUSH = 3;                  压缩刷新模式，用于清除所有待处理的输出并重置拆卸器。
         *     public static final int HUFFMAN_ONLY = 2;                仅用于霍夫曼编码的压缩策略。
         *     public static final int NO_COMPRESSION = 0;              不压缩的压缩级别。
         *     public static final int NO_FLUSH = 0;                    用于实现最佳压缩结果的压缩刷新模式。
         *     public static final int SYNC_FLUSH = 2;                  用于清除所有未决输出的压缩刷新模式; 可能会降低某些压缩算法的压缩率。
         */

        //使用指定的压缩级别创建一个新的压缩器。
        Deflater deflater = new Deflater(Deflater.BEST_COMPRESSION);
        //设置压缩输入数据。
        deflater.setInput(unzipString.getBytes());
        //当被调用时，表示压缩应该以输入缓冲区的当前内容结束。
        deflater.finish();

        final byte[] bytes = new byte[256];
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream(256);

        while (!deflater.finished()) {
            //压缩输入数据并用压缩数据填充指定的缓冲区。
            int length = deflater.deflate(bytes);
            outputStream.write(bytes, 0, length);
        }
        //关闭压缩器并丢弃任何未处理的输入。
        deflater.end();
        return Base64.encodeToString(outputStream.toByteArray());
    }

    /**
     * 解压缩
     */
    public static String unzipString(String zipString) {
        byte[] decode = Base64.decode(zipString);
        //创建一个新的解压缩器  https://www.yiibai.com/javazip/javazip_inflater.html

        Inflater inflater = new Inflater();
        //设置解压缩的输入数据。
        inflater.setInput(decode);
        final byte[] bytes = new byte[256];
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream(256);
        try {
            //finished() 如果已到达压缩数据流的末尾，则返回true。
            while (!inflater.finished()) {
                //将字节解压缩到指定的缓冲区中。
                int length = inflater.inflate(bytes);
                outputStream.write(bytes, 0, length);
            }
        } catch (DataFormatException e) {
            log.error(e.getMessage(), e);
            return null;
        } finally {
            //关闭解压缩器并丢弃任何未处理的输入。
            inflater.end();
        }

        return outputStream.toString();
    }
}
~~~

操作redis工具类

~~~java
package com.newboss.base.util;

import cn.hutool.core.lang.Assert;
import com.aliyun.openservices.shade.org.apache.commons.lang3.StringUtils;
import com.newboss.base.exception.ApplicationException;
import com.newboss.base.exception.RedisException;
import com.newboss.base.multidatasource.DataSourceType;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.connection.RedisConnection;
import org.springframework.data.redis.connection.RedisStringCommands;
import org.springframework.data.redis.connection.ReturnType;
import org.springframework.data.redis.core.HashOperations;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.types.Expiration;

import java.io.UnsupportedEncodingException;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;
import java.util.function.Supplier;

@Slf4j
public class RedisUtil {

    private static String redisCode = "utf-8";

    private static RedisTemplate<String, String> redisTemplate = SpringUtil.getBean("redisTemplate", RedisTemplate.class);

    private RedisUtil() {}

    /**
     * 字符串转为byte数组类型(统一编码)
     *
     * @param key
     *
     * @return
     */
    public static byte[] strToByte(String key) {
        try {
            return key.getBytes(redisCode);
        } catch (UnsupportedEncodingException e) {
            return null;
        }
    }

    public static String bytesToStr(byte[] bs) {
        try {
            return new String(bs, redisCode);
        } catch (UnsupportedEncodingException e) {
            return null;
        }
    }

    /**
     * 从指定的列表右边出队,添加到目的列表中
     *
     * @param srckey
     *            源列表
     * @param dstkey
     *            　目的列表
     * @return
     */
    public static String rpoppush(final String srckey, final String dstkey) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    try {
                        return new String(connection.rPopLPush(strToByte(srckey),
                                strToByte(dstkey)), redisCode);
                    } catch (UnsupportedEncodingException e) {
                        log.error(e.getMessage(), e);
                    }
                    return "";
                }
        );
    }

    /**
     * 获取指定列表的范围数据
     *
     * @param key
     *            　列表名
     * @param start
     *            　开始位置
     * @param end
     *            　结束位置
     * @return
     */
    public static List<String> lrange(final String key, final int start,
                                      final int end) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    List<String> result = new ArrayList<String>();
                    List<byte[]> bytelist = connection.lRange(strToByte(key),
                            start, end);
                    for (byte[] b : bytelist) {
                        try {
                            result.add(new String(b, redisCode));
                        } catch (UnsupportedEncodingException e) {
                            log.error(e.getMessage(), e);
                        }
                    }
                    return result;
                }
        );
    }

    /**
     * 从队列的左边取出一条数据
     *
     * @param key
     *            　列表名
     * @return
     */
    public static String lpop(final String key) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    byte[] result = connection.lPop(strToByte(key));
                    if (result != null) {
                        try {
                            return new String(result, redisCode);
                        } catch (UnsupportedEncodingException e) {
                            log.error(e.getMessage(), e);
                        }
                    }
                    return "";
                }
        );
    }

    /**
     * 从列表右边添加数据
     *
     * @param key
     *            列表名
     * @param values
     *            数据
     * @return
     */
    public static long rpush(final String key, final String... values) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    long result = 0;
                    for (String v : values) {
                        connection.rPush(strToByte(key), strToByte(v));
                    }
                    return result;
                }
        );
    }

    /**
     * 从列表右边添加数据,并且设置列表的存活时间
     *
     * @param key
     *            列表名
     * @param liveTime
     *            存活时间(单位 秒)
     * @param values
     *            数据
     * @return
     */
    public static long rpush(final String key, final int liveTime,
                             final String... values) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    long result = 0;
                    for (String v : values) {
                        connection.rPush(strToByte(key), strToByte(v));
                    }
                    if (liveTime > 0) {
                        connection.expire(strToByte(key), liveTime);
                    }
                    return result;
                }
        );
    }

    /**
     * 从队列的右边取出一条数据
     *
     * @param key
     *            列表名
     * @return
     */
    public static String rpop(final String key) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    byte[] result = connection.rPop(strToByte(key));
                    if (result != null) {
                        try {
                            return new String(result, redisCode);
                        } catch (UnsupportedEncodingException e) {
                            log.error(e.getMessage(), e);
                        }
                    }
                    return "";
                }
        );
    }

    /**
     * 从队列的右边取出一条数据，阻塞模式
     *
     * @param key
     *            列表名
     * @return
     */
    public static String brpop(final String key, final int timeout) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    List<byte[]> result = connection.bRPop(timeout, strToByte(key));
                    if (result != null && !result.isEmpty()) {
                        try {
                            return new String(result.get(0), redisCode);
                        } catch (UnsupportedEncodingException e) {
                            log.error(e.getMessage(), e);
                        }
                    }
                    return "";
                }
        );
    }

    /**
     * 把一个值添加到对应列表中
     *
     * @param key
     *            列表名
     * @param index
     *            　添加的位置
     * @param value
     *            　数据
     * @return
     */
    public static String lset(final String key, final long index,
                              final String value) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    connection.lSet(strToByte(key), index, strToByte(value));
                    return "success";
                }
        );
    }

    /**
     * 把所有数据添加到一个列表中
     *
     * @param key
     *            列表名
     * @param values
     *            　数据
     * @return
     */
    public static long lpush(String key, String... values) {
        return lpush(key, 0, values);
    }

    /**
     * 把所有数据添加到一个列表中,并且设置列表的存活时间
     *
     * @param key
     *            列表名
     * @param values
     *            数据
     * @param liveTime
     *            存活时间--单位(秒)
     * @return
     */
    public static long lpush(final String key, final int liveTime,
                             final String... values) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    long result = 0;
                    for (String v : values) {
                        result = connection.lPush(strToByte(key), strToByte(v));
                    }
                    if (liveTime > 0) {
                        connection.expire(strToByte(key), liveTime);
                    }
                    return result;
                }
        );
    }

    /**
     * 返回列表的长度
     *
     * @param key
     * @return
     */
    public static long llen(final String key) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    return connection.lLen(strToByte(key));
                }
        );
    }

    /**
     * 删除列表中对应值的元素
     *
     * @param key
     *            列表名
     * @param count
     *            删除多少个相同的元素
     * @param value
     *            数据
     * @return
     */
    public static long lrem(final String key, final long count,
                            final String value) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    return connection.lRem(strToByte(key), count, strToByte(value));
                }
        );
    }

    /**
     * 通过key删除
     *
     * @param keys
     */
    public static long del(final String... keys) {
        return redisTemplate.execute((RedisConnection connection)-> {
                    long result = 0;
                    for (String k : keys) {
                        result = connection.del(strToByte(k));
                    }
                    return result;
                }
        );
    }

    /**
     * 添加key value 并且设置存活时间(byte)
     *
     * @param key
     * @param value
     * @param liveTime 单位秒
     */
    public static void set(final byte[] key, final byte[] value,
                           final int liveTime) {
        redisTemplate.execute((RedisConnection connection) ->{
                    connection.set(key, value);
                    if (liveTime > 0) {
                        connection.expire(key, liveTime);
                    }
                    return 1L;
                }
        );

    }

    /**
     * 添加key value 并且设置存活时间(byte)
     *
     * @param key
     * @param value
     * @param liveTime 单位豪秒
     */
    public static void set(final byte[] key, final byte[] value,
                           final long liveTime, TimeUnit timeUnit) {
        redisTemplate.execute((RedisConnection connection) ->{
                    connection.set(key, value);
                    if (liveTime > 0) {
                        switch (timeUnit) {
                            case SECONDS:
                                connection.expire(key, liveTime);
                                break;
                            case MILLISECONDS:
                                connection.pExpire(key, liveTime);
                                break;
                            default:
                                throw new RuntimeException("only supports second & millisSecond");
                        }
                    }
                    return 1L;
                }
        );

    }

    /**
     * 添加key value 并且设置存活时间
     *
     * @param key
     * @param value
     * @param liveTime
     *            单位秒
     */
    public static void set(String key, String value, int liveTime) {
        set(strToByte(key), strToByte(value), liveTime);

    }

    /**
     * 添加key value 并且设置存活时间
     *
     * @param key
     * @param value
     * @param liveTime
     *
     */
    public static void set(String key, String value, long liveTime, TimeUnit timeUnit) {
        set(strToByte(key), strToByte(value), liveTime, timeUnit);
    }

    /**
     * 添加key value
     *
     * @param key
     * @param value
     */
    public static void set(String key, String value) {
        set(key, value, 0);
    }

    /**
     * 添加key value (字节)(序列化)
     *
     * @param key
     * @param value
     */
    public static void set(byte[] key, byte[] value) {
        set(key, value, 0);
    }

    /**
     * 获取redis value (String)
     *
     * @param key
     * @return
     */
    public static String get(final String key) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    byte[] result = connection.get(strToByte(key));
                    if (result != null) {
                        try {
                            return new String(result, redisCode);
                        } catch (UnsupportedEncodingException e) {
                            throw new RuntimeException(e);
                        }
                    }
                    return "";
                }
        );
    }

    /**
     * 获取redis value (byte[])
     *
     * @param key
     * @return
     */
    public static byte[] get(final byte[] key) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    byte[] result = connection.get(key);
                    return result;
                }
        );
    }

    /**
     * 如果key不存在添加key value 并且设置存活时间(byte)，当key已经存在时，就不做任何操作
     *
     * @param key
     * @param value
     * @param liveTime
     */
    public static boolean setnx(final byte[] key, final byte[] value,
                             final int liveTime) {
        return redisTemplate.execute((RedisConnection connection) ->
                connection.set(key, value, Expiration.seconds(liveTime), RedisStringCommands.SetOption.SET_IF_ABSENT));
    }

    /**
     * 如果key不存在添加key value 并且设置存活时间，当key已经存在时，就不做任何操作
     *
     * @param key
     * @param value
     * @param liveTime
     *            单位秒
     */
    public static boolean setnx(String key, String value, int liveTime) {
        return setnx(strToByte(key), strToByte(value), liveTime);

    }

    /**
     * 如果key不存在添加key value，当key已经存在时，就不做任何操作
     *
     * @param key
     * @param value
     */
    public static boolean setnx(String key, String value) {
        return setnx(key, value, 0);
    }

    /**
     * 如果key不存在添加key value (字节)(序列化)，当key已经存在时，就不做任何操作
     *
     * @param key
     * @param value
     */
    public static boolean setnx(byte[] key, byte[] value) {
        return setnx(key, value, 0);

    }

    /**
     * 通过正则匹配keys
     *
     * @param pattern
     * @return
     */
    public static Set<String> keys(final String pattern) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    Set<String> result = new HashSet<String>();
                    Set<byte[]> data = connection.keys(strToByte(pattern));
                    for (byte[] d : data) {
                        try {
                            result.add(new String(d, redisCode));
                        } catch (UnsupportedEncodingException e) {
                            log.error(e.getMessage(), e);
                        }
                    }
                    return result;
                }
        );
    }

    /**
     * 检查key是否已经存在
     *
     * @param key
     * @return
     */
    public static boolean exists(final String key) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    return connection.exists(strToByte(key));
                }
        );
    }

    /**
     * 清空redis 所有数据
     *
     * @return
     */
    public static String flushDB() {
        return redisTemplate.execute((RedisConnection connection) -> {
                    connection.flushDb();
                    return "success";
                }
        );
    }

    /**
     * 查看redis里有多少数据
     */
    public static long dbSize() {
        return redisTemplate.execute((RedisConnection connection) -> {
                    return connection.dbSize();
                }
        );
    }

    /**
     * 检查是否连接成功
     *
     * @return
     */
    public static String ping() {
        return redisTemplate.execute((RedisConnection connection) -> {
                    return connection.ping();
                }
        );
    }

    /**
     * 设置key的生命周期
     *
     * @param key
     * @param seconds
     *            单位(秒)
     * @return
     */
    public static boolean expire(final String key, final int seconds) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    return connection.expire(strToByte(key), seconds);
                }
        );
    }

    public static boolean expire(final byte[] key, final int seconds) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    return connection.expire(key, seconds);
                }
        );
    }

    /**
     * 返回值为-1时 此键值没有设置过期日期
     * 返回值为-2时 不存在此键
     * 当seconds==null时 正在事务或管道中
     * @param key
     * @return
     */
    public static Long getExpire(String key) {
        return redisTemplate.opsForValue().getOperations().getExpire(key);
    }

    /**
     * 自增长
     *
     * @param key
     *            增长步长
     * @return
     */
    public static long incr(final String key) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    return connection.incr(strToByte(key));
                }

        );
    }

    /**
     * 自增长
     *
     * @param key
     *            增长步长
     * @return
     */
    public static long incrBy(final String key, final long len) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    return connection.incrBy(strToByte(key), len);
                }
        );

    }

    /**
     * 自增长
     *
     * @param key
     * @param len
     *            增长步长
     * @return
     */
    public static double incrBy(final String key, final double len) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    return connection.incrBy(strToByte(key), len);
                }
        );
    }

    public static Object eval(final String luaCommand) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    return connection.eval(strToByte(luaCommand), null, 0);
                }
        );
    }

    public static Object eval(final String luaCommand, byte[]... keysAndArgs) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    return connection.eval(strToByte(luaCommand), ReturnType.INTEGER, 0, keysAndArgs);
                }
        );
    }

    /**
     * 添加key 哈希表
     *
     * @param key
     * @param map
     */
    public static void hMSet(String key, Map<String, String> map) {
        hMSet(key, map, 0);
    }

    /**
     * 添加key 哈希表 并且设置存活时间
     *
     * @param key
     * @param map
     * @param liveTime
     */
    public static void hMSet(String key, Map<String, String> map, int liveTime) {
        Map<byte[], byte[]> hashes = new LinkedHashMap<byte[], byte[]>();
        for (Entry<String, String> entry : map.entrySet()) {
            hashes.put(strToByte(entry.getKey()), strToByte(entry.getValue()));
        }
        hMSet(strToByte(key), hashes, liveTime);
    }

    /**
     * 添加key hashes 并且设置存活时间(byte)
     *
     * @param key
     * @param hashes
     *            哈希表
     * @param liveTime
     */
    public static void hMSet(final byte[] key, final Map<byte[], byte[]> hashes,
                             final int liveTime) {
        redisTemplate.execute((RedisConnection connection) -> {
                    connection.hMSet(key, hashes);
                    if (liveTime > 0) {
                        connection.expire(key, liveTime);
                    }
                    return 1L;
                }
        );

    }

    /**
     * 获取redis value (Map<String, String>)
     *
     * @param key
     * @return
     */
    public static Map<String, String> hMGet(final String key) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    Map<byte[], byte[]> result = connection.hGetAll(strToByte(key));
                    Map<String, String> hashes = new LinkedHashMap<String, String>();
                    if (result != null && !result.isEmpty()) {
                        try {
                            for (Entry<byte[], byte[]> entry : result.entrySet()) {
                                hashes.put(new String(entry.getKey(), redisCode),
                                        new String(entry.getValue(), redisCode));
                            }
                            return hashes;
                        } catch (UnsupportedEncodingException e) {
                            log.error(e.getMessage(), e);
                        }
                    }
                    return hashes;
                }
        );
    }

    /**
     * 添加到set
     *
     * @param key
     * @param values
     * @return
     */
    public static long sadd(final String key, final String... values) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    long result = 0;
                    for (String v : values) {
                        result += connection.sAdd(strToByte(key), strToByte(v));
                    }
                    return result;
                }
        );
    }

    /**
     * 从set中取值
     *
     * @param key
     * @return
     */
    public static String spop(final String key) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    byte[] result = connection.sPop(strToByte(key));
                    if (result != null) {
                        try {
                            return new String(result, redisCode);
                        } catch (UnsupportedEncodingException e) {
                            log.error(e.getMessage(), e);
                        }
                    }
                    return "";
                }
        );
    }

    public static long scard(final String key) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    return connection.sCard(strToByte(key));
                }
        );
    }

    public static boolean sismember(final String key, final String value) {
        return redisTemplate.execute((RedisConnection connection) -> {
                    return connection.sIsMember(strToByte(key), strToByte(value));
                }
        );
    }

    public static void srem(final String key, final String value) {
        redisTemplate.execute((RedisConnection connection) -> {
                    connection.sRem(strToByte(key), strToByte(value));
                    return null;
                }
        );
    }

//    public static  String hGet(String key, String field) {
//        return redisTemplate.execute((RedisConnection connection) -> {
//                byte[] result = connection.hGet(strToByte(key), strToByte(field));
//                String str=null;
//                if (result != null) {
//                    try {
//                        str = new String(result, redisCode);
//                    } catch (UnsupportedEncodingException e) {
//                        log.error(e.getMessage(), e);
//                    }
//                }
//                return str;
//            }
//        );
//    }

    /**
     * 添加一条记录到hash
     * <p>
     * 若存在相同的hash key 则替换
     * 如果不希望替换,请参考 {@link HashOperations#putIfAbsent(Object, Object, Object)}
     * <p>
     * hash不支持对每一个hash key设置ttl 只支持对一整个key设置ttl version 5.0
     *
     * @param key     外层key
     * @param hashKey hash里面的key
     * @param value   要存放的值
     */
    public static void hSet(String key, String hashKey, String value) {
        redisTemplate.opsForHash().put(key, hashKey, value);
    }

    /**
     * 获取hash里面的一条记录
     *
     * @param key     外层key
     * @param hashKey hash里面的key
     * @return
     */
    public static String hGet(String key, String hashKey) {
        HashOperations<String, String, String> operations = redisTemplate.opsForHash();
        return operations.get(key, hashKey);
    }

    public static Integer getRandomTimeout(Integer timeoutMillisSeconds) {
        Assert.notNull(timeoutMillisSeconds, "timeoutMillisSeconds can't be null");
        return ThreadLocalRandom.current().nextInt(timeoutMillisSeconds);
    }

    /**
     *
     * @param syncTask
     * @param lockKey
     * @param lockFlag
     * @param lockTimeout 单位秒
     */
    public static void tryLockAndExecute(Runnable syncTask, String lockKey, String lockFlag, int lockTimeout, String errMsg) {
        try {
            boolean lock = RedisUtil.setnx(lockKey, lockFlag, lockTimeout);
            if(!lock) {
                throw new RuntimeException(OptionalKit.getOrDefault(errMsg, String.format("failed to obtain an lockKey %s, lockFlag %s for execute", lockKey, lockFlag)));
            }
            syncTask.run();
        } finally {
            String value = RedisUtil.get(lockKey);
            if(lockFlag.equals(value)) {
                RedisUtil.del(lockKey);
            }
        }
    }

    /**
     *
     * @param syncTask
     * @param lockKey
     * @param lockFlag
     * @param lockTimeout 单位秒
     */
    public static <R> R tryLockAndExecute(Supplier<R> syncTask, String lockKey, String lockFlag, int lockTimeout, String errMsg) {

        try {
            boolean lock = RedisUtil.setnx(lockKey, lockFlag, lockTimeout);
            if(!lock) {
                throw new RuntimeException(OptionalKit.getOrDefault(errMsg, String.format("failed to obtain an lockKey %s, lockFlag %s for execute", lockKey, lockFlag)));
            }
            return syncTask.get();
        } finally {
            String value = RedisUtil.get(lockKey);
            if(lockFlag.equals(value)) {
                RedisUtil.del(lockKey);
            }
        }
    }

    /**
     *
     * @param syncTask
     * @param lockKey
     * @param lockFlag
     * @param tryAcquireTimeout 继续获取锁超时时间
     * @param lockTimeout 单位秒
     * @param reentrantRedisKeyPrefix 可重入获取锁的redis业务前缀
     * @param errorMsg 错误信息
     * */
    public static void tryLockAndExecute(Runnable syncTask, String lockKey, String lockFlag
            , int tryAcquireTimeout, int lockTimeout, String reentrantRedisKeyPrefix, String errorMsg) {

        long nano = System.nanoTime();
        long nsOfOneSecond = 1000000000;
        boolean locked = false;
        try {
            while ((System.nanoTime() - nano) < tryAcquireTimeout * nsOfOneSecond) {
                if (RedisUtil.setnx(lockKey, lockFlag, lockTimeout)) {
                    locked = true;
                    log.debug("add RedisLock[{}].", lockKey);
                    break;
                } else {
                    locked = isReentrantByKeyPrefix(lockKey, reentrantRedisKeyPrefix, lockTimeout);
                    if(locked) {
                       break;
                    }
                }
                Thread.sleep(5, ThreadLocalRandom.current().nextInt(500));
            }
            // 锁超时， 阻止程序继续往下执行
            if (!locked) {
                throw RedisException.TRY_LOCK_FAILED.format(lockKey, lockFlag);
            }
            syncTask.run();
        } catch (Exception e) {
            if(e instanceof RedisException) {
                log.error("RedisException: {}", ((RedisException) e).getMsg());
                if(StringUtils.isNotBlank(errorMsg)) {
                    throw new RuntimeException(errorMsg);
                }
                throw RedisException.TRY_LOCK_FAILED.format(lockKey, lockFlag);
            }
            throw new RuntimeException(e);
        } finally {
            String value = RedisUtil.get(lockKey);
            if(lockFlag.equals(value)) {
                RedisUtil.del(lockKey);
            }
        }
    }

    private static boolean isReentrantByKeyPrefix(String lockKey, String reentrantRedisKeyPrefix, int lockTimeout) {
        //过期时间还有5秒可重入
        final int EXPIRE_TIME_LEFT_FOR_REENTRANT = 5;

        if(StringUtils.isBlank(reentrantRedisKeyPrefix)) {
            return false;
        }

        //首先获取过期时间
        Long expiredSeconds = RedisUtil.getExpire(lockKey);

        if(expiredSeconds != null && expiredSeconds > EXPIRE_TIME_LEFT_FOR_REENTRANT) {
            String lockValue = RedisUtil.get(lockKey);
            //判断是否可重入
            if(lockValue != null && StringUtil.contains(lockValue, reentrantRedisKeyPrefix)) {
                String lockValueForCheck = RedisUtil.get(lockKey);
                if(StringUtils.equals(lockValueForCheck, lockValue)) {
                    //刷新过期时间
                    RedisUtil.expire(lockKey, lockTimeout);
                    log.debug("reentrant RedisLock[{}].", lockKey);
                    return true;
                }
            }
        }
        return false;
    }

    /**
     *
     * @param syncTask
     * @param lockKey
     * @param lockFlag
     * @param tryAcquireTimeout 继续获取锁超时时间
     * @param lockTimeout 单位秒
     * @param reentrantRedisKeyPrefix 可重入获取锁的redis业务前缀
     * @param errorMsg 错误信息
     */
    public static <R> R tryLockAndExecute(Supplier<R> syncTask, String lockKey, String lockFlag
            , int tryAcquireTimeout, int lockTimeout, String reentrantRedisKeyPrefix, String errorMsg) {

        long nano = System.nanoTime();
        long nsOfOneSecond = 1000000000;
        boolean locked = false;
        try {
            while ((System.nanoTime() - nano) < tryAcquireTimeout * nsOfOneSecond) {
                if (RedisUtil.setnx(lockKey, lockFlag, lockTimeout)) {
                    locked = true;
                    log.debug("add RedisLock[{}].", lockKey);
                    break;
                } else {
                    locked = isReentrantByKeyPrefix(lockKey, reentrantRedisKeyPrefix, lockTimeout);
                    if(locked) {
                        break;
                    }
                }
                Thread.sleep(5, ThreadLocalRandom.current().nextInt(500));
            }
            // 锁超时， 阻止程序继续往下执行
            if (!locked) {
                throw RedisException.TRY_LOCK_FAILED.format(lockKey, lockFlag);
            }
            return syncTask.get();
        } catch (Exception e) {
            if(e instanceof RedisException) {
                log.error("RedisException: {}", ((RedisException) e).getMsg());
                if(StringUtils.isNotBlank(errorMsg)) {
                    throw new RuntimeException(errorMsg);
                }
                throw RedisException.TRY_LOCK_FAILED.format(lockKey, lockFlag);
            }
            throw new RuntimeException(e);
        }  finally {
            String value = RedisUtil.get(lockKey);
            if(lockFlag.equals(value)) {
                RedisUtil.del(lockKey);
            }
        }
    }
}

~~~

## 2、消息队列封装

监听标识

~~~JAVA
package com.newboss.base.mq;

import com.newboss.constants.MQConstants;

import java.lang.annotation.*;

/**
 * 监听标识
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Sub {

    /**
     * MQ选型
     */
    String mqType() default MQConstants.MQ_TYPE;

    /**
     * 应用名称
     */
    String appName() default MQConstants.APP_NAME;

    /**
     * 用于生成消息的 GID / TAG
     */
    String subTagKey();

    /**
     * 数据编码
     * @return
     */
    String charset() default "UTF-8";

    /**
     * 作为不同topic的区分key  
     * <p> 
     * xhboss -- 订阅的是星火boss部门topic
     * ssboss -- 订阅的是双师boss部门topic
     * xhmall -- 订阅的是c端topic
     * @return
     */
    String topicSelectKey() default "xhmall";

    /**
     * 完整的消息tag
     */
    String absTag() default "";

    /**
     * 程序处理异常时是否重新处理，true将会把数据再一次放到队列
     * @return
     */
    boolean requeue() default false;
}

~~~

使用如图所示： 

```java
    @Sub(subTagKey = MQConstants.MC_SYNC_SSBOSS_TWO_TEACHER_CLASS_CHANGE, topicSelectKey = "ssboss", absTag = "${bossTopic.ssbossTagKey.twoteacherclass}")
    public void syncSsBossTwoTeacherClassChange(String data) {
        DataChange dataChange = JSONObject.parseObject(data, DataChange.class);
        log.info("task: MC_SYNC_SSBOSS_TWO_TEACHER_CLASS_CHANGE, data : {}", data);
        BizDivisionSwitch.enableSs(() ->  searchService.realTimeSyncBossTwoTeacherClassDataChangeToEs(dataChange, DataSourceType.SS));
    }
```

推送标识

~~~java
package com.newboss.base.mq;

import com.newboss.constants.MQConstants;

import java.lang.annotation.*;

/**
 * 推送标识
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Pub {

    /**
     * MQ选型
     */
    String mqType() default MQConstants.MQ_TYPE;

    /**
     * 应用名称
     */
    String appName() default MQConstants.APP_NAME;

    /**
     * 数据编码
     * @return
     */
    String charset() default "UTF-8";

    /**
     * 延时时间
     * @return
     */
    long delaySecond() default 0;

    /**
     * 延时时间 从配置读取
     */
    String delaySecondConfig() default "";

    /**
     * 作为不同topic的区分key
     */
    String topicSelectKey() default "xhmall";

    /**
     * 用于生成消息的 GID / TAG
     */
    String subTagKey();

    /**
     * 完整的消息tag
     */
    String absTag() default "";
}
~~~

