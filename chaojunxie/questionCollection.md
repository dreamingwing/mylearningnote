# 头条

1、聊项目，画项目架构图，画一个用户从发起请求 到接收到响应 中间经过哪些服务 每个服务做什么事情 的流程图

2、讲项目中的难点、挑战，你是如何解决的

3、redis 中有几种类型 & 各自底层怎么实现的 & 项目中哪个地方用了什么类型，怎么使用的

4、redis如何实现分布式锁，zk如何实现分布式锁，两者的区别。如果service还没执行完，分布式锁在redis中已经过期了，怎么解决这种问题

 在使用 redis 分布式锁的时候，可能会碰到，服务执行时间比较长，但此时redis锁的过期时间到了，那 redis 会解锁，导致其他服务能同时访问的问题，改如何解决？

       只要客户端一旦加锁成功，启动一个watch线程，他是一个后台线程，会每隔10秒检查一下，如果客户端还持有锁key，那么就会不断的延长锁key的生存时间。
    
      假如加锁的时间是30秒，如果加锁的业务没有执行完，那么到 30-10 = 20秒的时候，就会进行一次续期,把锁重置成30秒
5、synchronized底层实现，加在方法上和加在同步代码块中编译后的区别、类锁、对象锁

6、锁升级的过程

7、java运行时区域 及 各个区域的作用、对GC的了解、java内存模型 及 为什么要这么设计

8、对索引的理解，组合索引，索引的最佳实践

9、countDownLatch用过没有，在项目中如何使用的，对aqs 的了解

10、写生产者消费者问题，考虑高并发的情况，可以使用Java 类库，白纸写代码

11、设计一个发号器，考虑集群和高并发的情况，要求发号器生成的id是递增趋势，通过id可以区分出来是今天生成的id还是昨天生成的id，但是生成的id中不能直接带有日期，要具有一定的混淆功能，白纸写代码

12、一个二位数组，每个元素都可以往上下左右四个方向走，寻找最长递增路径。如下图所示，最长递增路径即红色字体路径。白纸写代码。

# 美团

1、数据库和缓存的一致性问题。先更新数据库，再更新缓存，若更新完数据库了，还没有更新缓存，此时有请求过来了，访问到了缓存中的数据，怎么办？

2、聚簇索引/非聚簇索引，mysql索引底层实现，为什么不用B-tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方

如果我们使用哈希作为底层的数据结构，遇到上述的场景时，使用哈希构成的主键索引或者辅助索引可能就没有办法快速处理了，它对于处理范围查询或者排序性能会非常差，只能进行全表扫描并依次判断是否满足条件。

全表扫描对于数据库来说是一个非常糟糕的结果，这其实也就意味着我们使用的数据结构对于这些查询没有其他任何效果，最终的性能可能都不如从日志中顺序进行匹配。

由于所有的节点都可能包含目标数据，我们总是要从根节点向下遍历子树查找满足条件的数据行，这个特点带来了大量的随机 I/O，也是 B 树最大的性能问题。

B+ 树中就不存在这个问题了，因为所有的数据行都存储在叶节点中，而这些叶节点可以**通过『指针』依次按顺序连接**，当我们在如下所示的 B+ 树遍历数据时可以直接在多个子节点之间进行跳转，这样能够节省大量的磁盘 I/O 时间，也不需要在不同层级的节点之间对数据进行拼接和排序；通过一个 B+ 树最左侧的叶子节点，我们可以像链表一样遍历整个树中的全部数据，我们也可以引入双向链表保证倒序遍历时的性能

有些读者可能会认为使用 B+ 树这种数据结构会增加树的高度从而增加整体的耗时，然而高度为 3 的 B+ 树就能够存储千万级别的数据，实践中 B+ 树的高度最多也就 4 或者 5，所以这并不是影响性能的根本问题。

- 哈希虽然能够提供 `O(1)` 的单数据行操作性能，但是对于范围查询和排序却无法很好地支持，最终导致全表扫描；
- B 树能够在非叶节点中存储数据，但是这也导致在查询连续数据时可能会带来更多的随机 I/O，而 B+ 树的所有叶节点可以通过指针相互连接，能够减少顺序遍历时产生的额外随机 I/O；

3、mysql默认的事务隔离级别，mvcc，rr怎么实现的，rc如何实现的

4、mysql间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的sql语句，死锁发生了如何解决，mysql有没有提供什么机制去解决死锁

5、谈下对GC的了解，何为垃圾，有哪些GC算法，有哪些垃圾回收器，cms和g1的区别，emm，还有一个直击灵魂的问题，看过cms的源码吗，

6、有没有排查过线上oom的问题，如何排查的

7、说说对java中集合类的理解，项目中用过哪些，哪个地方用的，如何使用的

8、对CAS的理解，CAS带来的问题，如何解决这些问题

9、volatile底层、synchronized底层、锁升级的过程、MESI

