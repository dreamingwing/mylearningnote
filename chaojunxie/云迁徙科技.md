#   云徙科技

1. 拆成了什么模块

2. 国际ccs库存是怎么设计

3. 怎么防止超卖

4. 库存的锁，锁什么对象

5. 流量大了以后，下单扣库存，怎么优化(不用锁？锁会降低性能)

6. 缓存里面的库存和db里面库存不一致，要怎样

7. 分布式事务

     hamily  (tcc框架)

8. 缓存穿透

9. 缓存击穿

10. 数据量多大，最大的单表多大

     

11. java是值传递还是引用传递

    基本类型值传递 拷贝一份值

    引用类型引用传递  堆中的对象不变  改变地址

12. 并发的bug源头原因-》内存可见性和竞态条件

     内存可见性：一个线程对一个资源的修改，另外一个线程不能马上看到修改，因为一条线程的数据读写不一定从内存  直接读取，而是从存储或者寄存器中获取

     竞态条件：多个线程操作同一个资源，对先后访问的顺序是敏感的

13. volatile关键字

    可以保证共享资源内存可见性:因为JMM，线程之间共享的一些变量是存在可见性问题的。volatile关键字会强制线程对这样的变量操作的时候，都必须同步到内存。这样就能解决内存可见性的问题。

    禁止指令重排：JVM执行指令的时候回对指令之间的顺序做一些优化，让执行效率更高，这句叫做指令重排。但是有的是，会带来一些问题。

    不能保证原子操作

14. mybatis分页插件的原理

    mybatis有个分页插件的拦截器，需要配置到mybatis的配置文件当中

    分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。

    举例：select * from student，拦截sql后重写为：select t.* from （select * from student）t limit 0，10

15. ThreadLocal

    每个线程拥有自己独有的资源，本质是Thread有一个ThreadLocalMap的对象，当往Thread中写入数据时，key为当前ThreadLocal对象，value为写入的值；其中的key为弱引用，value为强引用，最后需要将ThreadLocal对象清除，不然不造成内存泄露

16. HashMap 1.7和1.8的区别

    HashMap1.7  :采用的是数组+链表的方式存储

    HashMap1.8  :采用的是数组+链表+红黑树的方式存储

    

17. mysql怎么排查慢查询

    启动慢查询日志

    根据explain+sql_no_cache  查看Select_type、possibleKey、key、rows几个字段   看看哪些索引没有用上

    根据分析结果，是否符合最左前缀原则

     用explain+sql_no_cache，在实际环境商品跑一下这条sql。使用sql_no_cache的原因是防止缓存的干扰关注点

    在possible_keys、keys以及rows上面，看下是否用上了期望中的索引

    show index from 看下这个表的索引，关注下cardinality这列，这列能体现这个数据的多样性

    有些时候选错索引，是因为mysql的统计出了问题，可以用analyze table来修正

    如果还是不行，可能是因为mysql觉得现在的选择是最优的，这是因为有时候是否需要回表等因素

    可以使用下force index语句来指明用的哪个索引来验证使用这个索引的想法

    各个索引

    避免索引失效

18. mysql页分裂

    B+树添加过程中尽量保持主键有一定的规则性，不然会频繁造成页分裂产生性能问题

    这是因为聚簇索引采用的是平衡二叉树算法，而且每个节点都保存了该主键所对应行的数据，假设插入数据的主键是自增长的，那么根据二叉树算法会很快的把该数据添加到某个节点下，而其他的节点不用动；但是如果插入的是不规则的数据，那么每次插入都会改变二叉树之前的数据状态。从而导致了页分裂。

19. 是否可以用字符串做主键

    可以，但是不推荐，主键一般都会用来构建索引，同时需要满足排序。字符串不太适合用来排序，比较的时性能太低，产生也分裂

